module immutable/intmapextrasv1

import immutable/option
import immutable/list

// bitwise and
extern pure def andbit(x: Int, y: Int): Int = 
    "(x & y)" 
// bitwise not
extern pure def notbit(x: Int): Int =
    "(~x)"
// bitwise xor
extern pure def xorbit(x: Int, y: Int): Int =
    "(x ^ y)"

//floor
extern pure def floor(x: Int): Int =
    "(x)"


//Insertion und join auf basis vom Patricia-tree + fillup und delete

//prefix: Nodes die collapsed wurden enthalten den elimierten Pfad als prefix, depth: branching bit m, wie in v3
type Dict[A] {
    Empty();
    Leaf(actualkey: Int, value: A);
    Branch(prefix: Int, branchbit: Int, left: Dict[A], right: Dict[A])

}

def even(x: Int)={
    mod(x,2)==0
}

def odd(x: Int)={
    not(even(x))
}

def zerobit(x: Int, y: Int)={
    andbit(x, y) == 0
}

def mask(x: Int, y: Int): Int={
    andbit(x, y-1)
}

def matchprefix(x: Int, y: Int, z: Int)={
    mask(x, z) == y
}


def lookup[A](key: Int, dict: Dict[A]): Option[A]={
    dict match{
        case Empty() => None()
        case Leaf(actualkey, value) => if(actualkey == key){
            Some(value)
            } else {None()}
        case Branch(prefix, branchbit, leftbranch, rightbranch) => if(not (matchprefix(key, prefix, branchbit))){ 
            None()                                                   
        } else if(zerobit(key, branchbit)){
            lookup(key, leftbranch)
        } else {
            lookup(key, rightbranch)
        }
    } 
}

// verbindet zwei nicht-leere Bäume miteinander, deren längste Prefixe nicht ineinander enthalten sein dürfen
def join[A](xprefix: Int, xtree: Dict[A], yprefix: Int, ytree: Dict[A]): Dict[A]={ 
    val m = branchingbit(xprefix, yprefix)
    if(zerobit(xprefix, m)){
        branch(mask(xprefix, m), m, xtree, ytree)
    } else{
        branch(mask(xprefix, m), m, ytree, xtree)
    }
}
// einen Wert (insvalue) in einer key-stelle im Baum einfügen
def insert[A](key: Int, insvalue: A, dict: Dict[A]): Dict[A]={
    dict match{
        case Empty() => Leaf(key, insvalue)
        case Leaf(actualkey, actualvalue) => if(actualkey == key){
            Leaf(key, insvalue) 
        }else {
            join(key, Leaf(key, insvalue), actualkey, dict)
        }
        case Branch(prefix, branchbit, leftbranch, rightbranch) => if(matchprefix(key, prefix, branchbit)){
            if(zerobit(key, branchbit)){
                branch(prefix, branchbit, insert(key, insvalue, leftbranch), rightbranch)
            }else{
                branch(prefix, branchbit, leftbranch, insert(key, insvalue, rightbranch))
            }
        }else{
            join(key, Leaf(key, insvalue), prefix, dict)
        }
        
    }
}

def merge[A](xtree: Dict[A], ytree: Dict[A]): Dict[A]={
    (xtree, ytree) match{
        case (Empty(), ytree) => ytree
        case (xtree, Empty()) => xtree
        case (Leaf(xkey, xvalue), ytree) => insert(xkey, xvalue, ytree)
        case (xtree, Leaf(ykey, yvalue)) => insert(ykey, yvalue, xtree)
        case (Branch(xprefix, xbranchbit, xleftbranch, xrightbranch), 
              Branch(yprefix, ybranchbit, yleftbranch, yrightbranch)) => if(xbranchbit  == ybranchbit && xprefix == yprefix){// Bäume haben selben Prefix
                branch(xprefix, xbranchbit, merge(xleftbranch, yleftbranch), merge(xrightbranch, yrightbranch))
              } else if(xbranchbit < ybranchbit && matchprefix(yprefix, xprefix, xbranchbit)){  //xprefix ist in yprefix enthalten
                if(zerobit(yprefix, xbranchbit)){
                    branch(xprefix, xbranchbit, merge(xleftbranch, ytree), xrightbranch)
                } else {
                    branch(xprefix, xbranchbit, xleftbranch, merge(xrightbranch, ytree))
                }
              } else if(xbranchbit > ybranchbit && matchprefix(xprefix, yprefix, ybranchbit)){ //yprefix ist in xprefix enthalten
                if(zerobit(xprefix, ybranchbit)){
                    branch(yprefix, ybranchbit, merge(xtree, yleftbranch), yrightbranch)
                } else {
                    branch(yprefix, ybranchbit, yleftbranch, merge(xtree, yrightbranch))
                }
              } else { //xtree und ytree haben keinen gemeinsamen prefix
                join(xprefix, xtree, yprefix, ytree)
              }
    }
}

// füllt einen leeren Baum mit n (Elementen) auf.
// könnte noch vlt eine Liste mitbekommen, die den baum auffüllt
def fillup(amount: Int): Dict[Int]={
    var t = Empty();
    var x = 1;
    while (x <= amount) {
        t = insert(x, x*10, t);
        x = x + 1;
    }
    t
}

//löscht einen Eintrag an dem gewählten key
def delete[A](delkey: Int, dict: Dict[A]): Dict[A] = {
    dict match{
        case Empty() => Empty()
        case Leaf(actualkey, value) => if(actualkey == delkey){
            Empty()
        } else {
            Leaf(actualkey, value)
        }
         case Branch(prefix, branchbit, Leaf(actualkey1, value1), Leaf(actualkey2, value2)) => if(actualkey1 == delkey){
            branch(prefix, branchbit, Empty(), Leaf(actualkey2, value2))
        } else if(actualkey2 == delkey){
            branch(prefix, branchbit, Leaf(actualkey1, value1), Empty())
        } else {
            dict
        }
        case Branch(prefix, branchbit, leftbranch, Leaf(actualkey, value)) => if(actualkey == delkey){
            branch(prefix, branchbit, leftbranch, Empty())
        } else {
            branch(prefix, branchbit, delete(delkey, leftbranch), Leaf(actualkey, value))
        }
        case Branch(prefix, branchbit, Leaf(actualkey, value), rightbranch) => if(actualkey == delkey){
            branch(prefix, branchbit, Empty(), rightbranch)
        } else {
            branch(prefix, branchbit, Leaf(actualkey, value), delete(delkey, rightbranch))
        }
        case Branch(prefix, branchbit, leftbranch, rightbranch) =>  if(zerobit(delkey, branchbit)){
            branch(prefix, branchbit, delete(delkey, leftbranch), rightbranch)
        } else {
            branch(prefix, branchbit, leftbranch, delete(delkey, rightbranch))
        }
    }
}

// Hilfsfuktion
// findet den ersten bit, in dem sich x und y unterscheiden
def branchingbit(x: Int, y: Int): Int={
    lowestbit(xorbit(x, y))
}

//Hilfsfunktion
// das kleinste Bit einer Zahl
def lowestbit(x: Int): Int={
    if(odd(x)){
        1
    }else{
        2*lowestbit(floor(x/2))
    }
}

//Idee: der smart-constructor garantiert, dass es kein Empty-Knoten als child-knoten gibt.  
// Der Pfad zu einem nicht-alleinstehenden Leaf wird collapsed und der gestrichene Pfad als Prefix im verbunden Knoten gespeichert.
// so gibt es einen Baum, der immer zwei Childnodes und/oder Leafs hat -> keine Empty()-Teile.
def branch[A](prefix: Int, branchbit: Int, dict1: Dict[A], dict2: Dict[A]): Dict[A]={
    (dict1, dict2) match{
        case (Empty(), Empty()) => Empty() 
        case (Empty(), r) => r
        case (l, Empty()) => l
        case (l, r) => Branch(prefix, branchbit, l, r)
    } 
}

def main() = {
    val t0 = branch(0, 1, branch(2, 4, Leaf(2, "A"), Leaf(6, "B")), Leaf(1, "C"));
    val t1 = branch(0, 1, Leaf(0, "X"), branch(3, 4, Leaf(3, "Y"), Leaf(7, "Z")));
    val t2 = branch(0, 1, branch(0, 2, Leaf(0, "A"), Leaf(2, "B")), branch(1, 2, Leaf(1, "C"), Leaf(3, "D")));
    val t3 = branch(0, 2, Leaf(0 ,"A"), branch(2, 4, Leaf(2, "B"), Leaf(6, "C")))
    val t4 = branch(3, 4, Leaf(3, "D"), Leaf(7, "E"))


    val f1 = fillup(10)
    println(f1)

    val del1 = delete(3,  Leaf(3, "D"))
    println(del1)

    val del2 = delete(3,  t4)
    println(del2)

    val del3 = delete(1,  t4)
    println(del3)

    val del4 = delete(1,  t0)
    println(del4)

    val del5 = delete(6,  t0)
    println(del5)

    val del6 = delete(3,  t2)
    println(del6)
}
