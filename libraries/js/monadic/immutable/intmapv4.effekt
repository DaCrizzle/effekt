module immutable/intmapv4

import immutable/option
import immutable/list

extern pure def andbit(x: Int, y: Int): Int = 
  "(x & y)" 

//floor
extern pure def floor(x: Int): Int =
    "(x)"


//Patricia-Tree

//prefix: Nodes die collapsed wurden enthalten den elimierten Pfad als prefix
type Dict[A] {
    Empty();
    Leaf(actualkey: Int, value: A);
    Branch(prefix: Int, branchbit: Int, leftbranch: Dict[A], rightbranch: Dict[A])

}
// testet ob ein Bit 0 ist mit bitand 
def zerobit(x: Int, y: Int)={
    andbit(x, y) == 0
}

def mask(x: Int, y: Int): Int={
    andbit(x, y-1)
}
def matchprefix(x: Int, y: Int, z: Int)={
    mask(x, z) == y
}


def lookup[A](key: Int, dict: Dict[A]): Option[A]={
    dict match{
        case Empty() => None()
        case Leaf(actualkey, value) => if(actualkey == key){
            Some(value)
            } else {None()}
        case Branch(prefix, branchbit, leftbranch, rightbranch) => if(not (matchprefix(key, prefix, branchbit))){ // kann auch weggelassen werden
            None()                                                   //
        } else if(zerobit(key, branchbit)){
            lookup(key, leftbranch)
        } else {
            lookup(key, rightbranch)
        }
    } 
}


//Idee: der smart-constructor garantiert, dass es kein Empty-Knoten als child-knoten gibt.  
// Der Pfad zu einem nicht-alleinstehenden Leaf wird collapsed und der gestrichene Pfad als Prefix im verbunden Knoten gespeichert.
// so gibt es einen Baum, der immer zwei Childnodes und/oder Leafs hat -> keine Empty()-Teile.
def branch[A](prefix: Int, branchbit: Int, dict1: Dict[A], dict2: Dict[A]): Dict[A]={
    (dict1, dict2) match{
        case (Empty(), Empty()) => Empty() 
        case (Empty(), rightbranch) => rightbranch
        case (leftbranch, Empty()) => leftbranch
        case (leftbranch, rightbranch) => Branch(prefix, branchbit, leftbranch, rightbranch)
    } 
}

def main() = {
    // Tests
    // soll None() ergeben (man geht aber von bäumen aus, deren tiefe >= 2 ist.)
    val te = Empty[Int]();
    val xe = lookup(2, te);
    println(xe)

    // soll Some(A), None(), None(), Some(B), None(),None()
    val t0 = branch(0, 1, Leaf(4, "A"), branch(1, 4, Leaf(1, "B"),Leaf(5, "C")));
    val x0 = lookup(4, t0);
    val x01 = lookup(0, t0);
    val x02 = lookup(8, t0);
    val x03 = lookup(1, t0);
    val x04 = lookup(9, t0);
    val x05 = lookup(3, t0); //da durch prefix 01 nicht erreichbar 7=111
    println(x0)
    println(x01)
    println(x02)
    println(x03)
    println(x04)
    println(x05)

    // soll Some(42), Some(17), None() ergeben //da branchbit=4 ist prefix 00
    val t1 = branch(0, 4, Leaf(0, 17), Leaf(4, 42));
    val x1 = lookup(4, t1);
    val x11 = lookup(0, t1);
    val x12 = lookup(3, t1);
    println(x1)
    println(x11)
    println(x12)

    // soll None() ergeben, weil prefix 0 ist
    val t2 = branch(1, 4, Leaf(1, true), Leaf(5, false));
    val x2 = lookup(4, t2);
    println(x2)
    

    // soll some(false),some(true),None()
    val t3 = branch(3, 4, Leaf(3, true), Leaf(7, false));
    val x3 = lookup(7, t3);
    val x31 = lookup(3, t3);
    val x32 = lookup(5, t3);
    println(x3)
    println(x31)
    println(x32)

    // soll Some(D) ergeben // obwohl nicht collapsed wird, braucht man den aktuellen prefix von 1 im rechten teil
    val t4 = branch(0, 1, branch(0, 2, Leaf(0, "A"), Leaf(2, "B")), branch(1, 2, Leaf(1, "C"), Leaf(3, "D")));
    val x4 = lookup(3, t4);
    println(x4)

    // soll Some(9), None() ergeben -> baum soll mindestens größe zwei sein eigentlich??
    val t5 = Leaf(3, 9);
    val x5 = lookup(3, t5);
    val x51 = lookup(2, t5);
    println(x5)
    println(x51)

    //test für nebenfunktionen
    println(mask(3,3))
    println(matchprefix(3,3,3))
    println(matchprefix(3,2,3))

}